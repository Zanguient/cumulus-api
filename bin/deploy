#! /usr/bin/env node
'use strict';

const _ = require('lodash');
const path = require('path');
const yaml = require('js-yaml');
const program = require('commander');
const fs = require('fs-extra');
const execSync = require('child_process').execSync;

function exec(cmd) {
  const stdout = execSync(cmd);
  console.log(stdout.toString());
  return stdout;
}

/**
 * Zips lambda functions and uploads them to a given S3 location
 * @param  {string} s3Path  A valid S3 URI for uploading the zip files
 * @param  {string} profile The profile name used in aws CLI
 */
function uploadLambdas(s3Path, profile) {
  // remove the build folder if exists
  fs.removeSync('build');

  // create the lambda folder
  fs.mkdirpSync('build/lambda');

  // zip files dist folders
  const distFolders = fs.readdirSync('dist');
  distFolders.forEach((dir) => {
    exec(`cd dist && zip -r ../build/lambda/$(basename ${dir} .js) ${dir}`);
  });

  // upload the artifacts to AWS S3
  // we use the aws cli to make things easier
  // this fails if the user doesn't have aws-cli installed
  exec(`cd build && aws s3 cp --recursive . ${s3Path}/ \
                              --profile ${profile} \
                              --exclude=.DS_Store`);
}

/**
 * Uploads the Cloud Formation template to a given S3 location
 * @param  {string} s3Path  A valid S3 URI for uploading the zip files
 * @param  {string} profile The profile name used in aws CLI
 */
function uploadCF(s3Path, profile) {
  // make sure cloudformation template exists
  try {
    fs.accessSync('config/cloudformation.yml');
  }
  catch (e) {
    console.log('cloudformation.yml is missing.');
    process.exit(1);
  }

  // upload CF template to S3
  exec(`aws s3 cp config/cloudformation.yml ${s3Path}/ \
                  --profile ${profile}`);
}

function cloudFormation(op, templateUrl, stackName, configBucket, artifactHash, profile) {
  exec(`aws cloudformation ${op}-stack \
--profile ${profile} \
--stack-name ${stackName} \
--template-url "${templateUrl}" \
--parameters "ParameterKey=ConfigS3Bucket,ParameterValue=${configBucket},UsePreviousValue=false" \
"ParameterKey=ArtifactPath,ParameterValue=${artifactHash},UsePreviousValue=false" \
--capabilities CAPABILITY_IAM`
  );
}

/**
 * Returns the configuration file and checks if the bucket specified
 * in the configuration file exists on S3. If the bucket does not exist,
 * it throws an error.
 * @param  {String} profile The profile name to use with AWS CLI
 * @return {Object}         The configuration Object
 */
function getConfig(profile) {
  // get the configs
  const config = yaml.safeLoad(fs.readFileSync('config/config.yml', 'utf8'));
  config.bucket = config.configBucket;

  // throw error if dist folder doesn't exist
  try {
    fs.accessSync('dist');
  }
  catch (e) {
    console.error('Dist folder is missing. Run npm install first.');
    process.exit(1);
  }

  // check if the configBucket exists, if not throw an error
  try {
    exec(`aws s3 ls s3://${config.bucket} --profile ${profile}`);
  }
  catch (e) {
    console.error(`${config.bucket} does not exist or your profile doesn't have access to it.
Either create the bucket or make sure your credentials have access to it`);
    process.exit(1);
  }

  return config;
}

/**
 * Generates a unique hash for the deployment from the files
 * in the dist forlder
 * @param  {Object} c Configuration file
 * @return {Object}   Returns the hash and the S3 bucket path for storing the data
 */
function getHash(c) {
  // get the artifact hash
  // this is used to separate deployments from different machines
  let artifactHash = exec(`find dist -type f | \
                           xargs shasum | shasum | awk '{print $1}' ${''}`);
  artifactHash = _.replace(artifactHash, '\n', '');

  // Make the S3 Path
  const s3Path = `s3://${c.bucket}/${c.stackName}-${c.stage}/${artifactHash}`;
  const url = `https://s3.amazonaws.com/${c.bucket}/${c.stackName}-${c.stage}/${artifactHash}`;

  return {
    hash: artifactHash,
    path: s3Path,
    url: url
  };
}

/**
 * Validates the CF template
 * @param  {Object} options The options object should include the profile name (optional)
 */
function validateTemplate(options) {
  const profile = options.profile;

  // Get the config
  const c = getConfig(options.profile);

  // Get the checksum hash
  const h = getHash(c);

  console.log('Validating the template');
  const url = `${h.url}/cloudformation.yml`;

  // Build and upload the CF template
  exec('babel-node config/builder.js');
  uploadCF(h.path, profile);

  exec(`aws cloudformation validate-template \
--template-url "${url}" \
--profile ${profile}`);
}

/**
 * Creates a CloudFormation stack
 * @param  {Object} options The options object should include the profile name (optional)
 */
function createStack(options) {
  const profile = options.profile;

  // Get the config
  const c = getConfig(options.profile);

  // Get the checksum hash
  const h = getHash(c);

  // upload lambdas and the cf template
  uploadLambdas(h.path, profile);

  // Build and upload the CF template
  exec('babel-node config/builder.js');
  uploadCF(h.path, profile);

  cloudFormation(
    'create',
    `${h.url}/cloudformation.yml`,
    c.stackName,
    c.bucket,
    c.hash,
    profile
  );
}

// the CLI activation
program
  .usage('COMMAND [options]')
  .option('-p, --profile <profile>', 'AWS profile name to use for authentication')
  .option('-r, --region', 'AWS region');

program
  .command('validate')
  .description('Validates the CF stack')
  .action(validateTemplate.bind(null, program));

program
  .command('create')
  .description('Creates the CF stack')
  .action(createStack.bind(null, program));

program
  .command('update')
  .description('Updates the CF stack');

program
  .parse(process.argv);
